---
title: "Design of yasss"
author: "Phillip Labuschagne"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  echo = FALSE
)
```

## Overall Design

yasss is designed to simulate genealogies which are stored in `data.frames`. A
high level summary of the core simulation functions are provided below:

`sim_pop`

* loop over number of generations
  + `sim_next_gen`
    - loop over all parents
      * `mutator`: mutate parent seq into offspring seq
  + `assign_fitness`: for most recent generation only

`get_fit_offspring`

It quickly became clear that most simulations will involve many datasets
generated with distinct sets of arguments. Functionality to track this extra
structure was added to yasss.

### `sim_pop`

### `sim_next_gen`

### `assign_fitness`

### `get_fit_offspring`

## Mutators

## Fitness evaluators

## Managing multiple simulations

The genealogy `data.frames` rapidly become too large to store in memory. Thus
there are two different approaches to managing the data from multiple
simulations. The first is to store the full genealogies, which is useful for
smaller simulations and for troubleshooting. The second approach reduces memory
consumption by summarizing each genealogy as it is simulated and only saving the
summary metrics. 

### Data structures

The data structure that saves only the summary metrics is called a `dsum` and
the summary metrics include:

- the percentiles of the distribution,
- the average of all the pairwise distances,
- and, an estimate of the distribution as produced by `density()`

Another structure that exists in the data is a pair (or set) generated by
applying different fitness cutoffs (criteria) to a genealogy. While the
computation of fitness scores is part of the `sim_pop` function, these scores
can be updated at a later stage using the `assign_fitness` function with the
`last_generation_only` argument set to FALSE. However, the current attempt at
managing the data will not handle this case where different
`fitness_evaluators` are used on a single genealogy. Instead, we will assume
that the fitness scores are only computed once during the call to `sim_pop`.
Future versions may lift this restriction on the data management component,
which will require the creation of a complex mechanism for managing the
argument sets, since the arguments that pertain specifically to `sim_pop` will
have to be separated from the arguments that are used only in the
`fitness_evaluator`.

A genealogy is typically used in one of three states: 

- the `fitness_scores` are ignored,
- `get_fit_offspring` is used to obtain a genealogy based only on fit
  individuals whose ancestors were also fit and finally, or 
- a random sampling from the last generation of the genealogy to match the
  size to a fitness restricted version that was generated with
  `get_fit_offspring`.

In general, we will further group these three states. Either we will
completely ignore the `fitness_scores` and just use the full genealogy or we
will construct a `fit_unfit_pair` in which `get_fit_offspring` is used to
generated a fitness restricted genealogy and then a random sample is generated
ignoring fitness scores to generated a matched (based on number of
individuals) pair.

This complexity is tracked in the following data structures:

- `fit_unfit_pair`: Two genealogies that were simulated with a single call to
  `sim_pop` and in one the fitness scores were used to restrict the
  individuals while in the other one a number of individuals were randomly
  sampled to ensure that the matched pair has the same number of individuals
  in the final generation.
- `arg_set`: A list that contains the arguments for `sim_pop` **AND** a
  required fitness **AND** a label. Thus an `arg_set` contains enough
  information to produce a fit/unfit pair. The label will be used later to
  associate the simulated data with the `arg_set` that was used to produce it.
  *Note: In the future multiple fitness evaluators may be applied to the same
  genealogy which will require a more complex `arg_set` concept.*
- `arg_collection` : A list of `arg_set`s.
- `gcol`: A collection of genealogies. This is the main memory consuming
  culprit. It is just a string of genealogy data.frames rbinded together with
  extra columns added that tracks the `genealogy_id`, the `arg_set` that was
  used to produce it and the fitness requirement that had to be satisfied.
- `dsum`: Summary of the distance matrix (percentiles, avg, density). This is a
  list with an element for each distance matrix that was produced.

#### `arg_set` and `arg_collection`

An example of the current version of an `arg_set`. Note that this will
probably be redesigned in a future version to allow multiple
`fitness_evaluators` to be applied to a single genealogy. Multiple `arg_set`s
are collected into a long list called the `arg_collection`. Each element in an
`arg_collection` is a single `arg_set`. The elements in an `arg_collection`
should not be named as the label that is part of the `arg_set` must be used as
the identifier.

```{r, eval = FALSE, echo = TRUE}
arg_set <- list(
  label = 'A',
  ancestors = paste(rep("A", 500), collapse = ''),
  r0 = 2,
  n_gen = n_gen,
  n_pop = Inf,
  mutator = list(fun = "mutator_uniform_fun",
                 args = list(mu = 1/250)),
  fitness_evaluator = list(fun = "fitness_evaluator_homology_fun",
                           args = list(comparators = paste(rep('XXXXC', 100), collapse = ''),
                                       h2fs = "h2fs_univariate_linear_fun")),
  required_fitness = 0.02
)
```

#### `gcol`

This is just a `data.frame` build by `rbind`ing many different genealogies
together and adding some columns to track the arguments that where used to
call `sim_pop` and that were used to remove individuals from the population.

The extra columns that must be added:

- **`sim_id`:** The id of the simulation. If many simulations are run in a
  loop using the same `arg_set` this column is the primary mechanism that
  distinguishes the simulations from each other.
- **`label`:** The label is used to match the simulation to the arguments that
  were used call `sim_pop` or sample from the genealogy.
- **`sampling`:** The sampling appoach applied to the original genealogy that
  was produced by `sim_pop`. Valid values include:
  * `fit_threshold`
  * `size_matched_sampling`
  * `none`

#### `dsum`

Due to the memory requiremented of storing full genealogies (or distance
matrices), it is often preferable to immediately compute and summarize a
distance matrix on the last generation of a genealogy and to delete both the
genealogy and distance matrix from memory. A `dsum` is a list in which each
element summarized a single distance matrix and contains additional elements
to help identify it. These additional elements are the same as the extra
columns added to the `gcol` data structure:

- **`sim_id`:** The id of the simulation. If many simulations are run in a
  loop using the same `arg_set` this column is the primary mechanism that
  distinguishes the simulations from each other.
- **`label`:** The label is used to match the simulation to the arguments that
  were used call `sim_pop` or sample from the genealogy.
- **`sampling`:** The sampling appoach applied to the original genealogy that
  was produced by `sim_pop`. Valid values include:
  * `fit_threshold`
  * `size_matched_sampling`
  * `none`

Each element of a `dsum` also have three additional elements that contains the
summary metrics:

- `perc`: the percentiles of the distribution,
- `avg_hd`: the average of all the pairwise distances,
- `dens` : an estimate of the distribution as produced by `density()`

The root level elements of the `dsum` list should not be named since the
identifier elements that match the extra columns of a `gcol` should be used to
identify the elements.

### Functions

Since this package is not implemented in an object oriented framework, the
data structures are not explicitly defined in code. The main focus of the
implementation is functions, so the data structures described need to guide
the development of specific functions that operate on and produce the
described datasets.

#### `check_arg_set`

This function validates an `arg_set` (a single element of an
`arg_collection`). Its function is similar to that of the validator of a
constructor. Given an `arg_set` it runs through a series of checks and
produces a list in which the name describe the check that was performed and
the entry is a bool indication pass (TRUE) or failure (FALSE).

#### `dsum_generation`

Computes a distance matrix and summary metrics on a single generation from a
genealogy.

#### `sim_proc_many_pops`

A large wrapper for `sim_pop`, `get_fit_offspring` and `dsum_generation`. It
has many arguments that control the amount of intermediary results are stored.

Primary arguments:

- `arg_collection`: All the `arg_set`s that will be used to simulate
  genealogies with `sim_pop` and `get_fit_offspring`.
- `n_pop`: The number of times `sim_pop` will be called each `arg_set`. Note
  that the number of datasets generated will depend on the way the fitness
  scores are used to sample from the genealogies.
- `fitness_processing`: The way that the fitness scores should be used to
  sample from the genealogy. Valid options include:
  * `none`: This will produce one dataset per genealogy.
  * `fit_unfit_pair`: This will use the threshold approach to remove all unfit
    individuals and their offspring. The remaining members of the last
    generation will be considered to be the fit member of the pair. An equal
    number of individuals will be sampled at random from the original
    genealogy to produce the unfit pair such that it is the same size as the
    fit pair.
  * `fit_unfit_unmatched_pair`: Same as `fit_unfit_pair` except that the
    unfit member will not be down sampled to size match the fit member.
- `output_genealogy`: Should the genealogy data sets be deleted to reduce
  memory usage? Valid options:
  * `last_gen_only`
  * `none`
  * `full`
- `output_dmat`: Should the distance matrix be included in the output?

Algorithm:

loop over arg_collection

loop over n_pop

call `sim_pop`

if statements controlling fitness evaluation
  Also add in all the identifiers

store genealogy(ies) into all_genealogies based on ouput_genealogy

loop over new genealogy(ies)

call dsum_generation

Add new dsum into all_dsums

Add the dmat into all_dmats based on output_dmat



