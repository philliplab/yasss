---
title: "Design of yasss"
author: "Phillip Labuschagne"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  echo = FALSE
)
```

## Overall Design

yasss is designed to simulate genealogies which are stored in `data.frames`. A
high level summary of the core simulation functions are provided below:

`sim_pop`

* loop over number of generations
  + `sim_next_gen`
    - loop over all parents
      * `mutator`: mutate parent seq into offspring seq
  + `fitness_evaluator`: for most recent generation only

It quickly became clear that most simulations will involve many datasets
generated with distinct sets of arguments. Functionality to track this extra
structure was added to yasss.

## Managing multiple simulations

The genealogy `data.frames` rapidly become too large to store in memory. Thus
there are two different approaches to managing the data from multiple
simulations. The first is to store the full genealogies, which is useful for
smaller simulations and for troubleshooting. The second approach reduces memory
consumption by summarizing each genealogy as it is simulated and only saving the
summary metrics. The summary metrics include:

- the percentiles of the distribution,
- the average of all the pairwise distances,
- and, an estimate of the distribution as produced by `density()`

Another structure that exists in the data is a pair (or set) generated by
applying different fitness cutoffs (criteria) to a genealogy. While the
computation of fitness scores is part of the `sim_pop` function, these scores
can be updated at a later stage using the `assign_fitness` function with the
`last_generation_only` argument set to FALSE. However, the current attempt at
managing the data will not handle this case where different
`fitness_evaluators` are used on a single genealogy. Instead, we will assume
that the fitness scores are only computed once during the call to `sim_pop`.
Future versions may lift this restriction on the data management component,
which will require the creation of a complex mechanism for managing the
argument sets, since the arguments that pertain specifically to `sim_pop` will
have to be separated from the arguments that are used only in the
`fitness_evaluator`.

A genealogy is typically used in one of three states: 

- the `fitness_scores` are ignored,
- `get_fit_offspring` is used to obtain a genealogy based only on fit
  individuals whose ancestors were also fit and finally, or 
- a random sampling from the last generation of the genealogy to match the
  size to a fitness restricted version that was generated with
  `get_fit_offspring`.

In general, we will further group these three states. Either we will
completely ignore the `fitness_scores` and just use the full genealogy or we
will construct a `fit_unfit_pair` in which `get_fit_offspring` is used to
generated a fitness restricted genealogy and then a random sample is generated
ignoring fitness scores to generated a matched (based on number of
individuals) pair.

This complexity is tracked in the following data structures:

- `fit_unfit_pair`: Two genealogies that were simulated with a single call to
  `sim_pop` and in one the fitness scores were used to restrict the
  individuals while in the other one a number of individuals were randomly
  sampled to ensure that the matched pair has the same number of individuals
  in the final generation.
- `arg_set`: A list that contains the arguments for `sim_pop` **AND** a
  required fitness **AND** a label. Thus an `arg_set` contains enough
  information to produce a fit/unfit pair. The label will be used later to
  associate the simulated data with the `arg_set` that was used to produce it.
  *Note: In the future multiple fitness evaluators may be applied to the same
  genealogy which will require a more complex `arg_set` concept.*
- `arg_collection` : A list of `arg_set`s.
- `gcol`: A collection of genealogies. This is the main memory consuming
  culprit. It is just a string of genealogy data.frames rbinded together with
  extra columns added that tracks the `genealogy_id`, the `arg_set` that was
  used to produce it and the fitness requirement that had to be satisfied.
- `dsum`: Summary of the distance matrix (percentiles, avg, density). This is a
  list with an element for each distance matrix that was produced.

### `arg_set` and `arg_collection`

An example of the current version of an `arg_set`. Note that this will
probably be redesigned in a future version to allow multiple
`fitness_evaluators` to be applied to a single genealogy. Multiple `arg_set`s
are collected into a long list called the `arg_collection`. Each element in an
`arg_collection` is a single `arg_set`. The elements in an `arg_collection`
should not be named as the label that is part of the `arg_set` must be used as
the identifier.

```{r, eval = FALSE, echo = TRUE}
arg_set <- list(
  label = 'A',
  ancestors = paste(rep("A", 500), collapse = ''),
  r0 = 2,
  n_gen = n_gen,
  n_pop = Inf,
  mutator = list(fun = "mutator_uniform_fun",
                 args = list(mu = 1/250)),
  fitness_evaluator = list(fun = "fitness_evaluator_homology_fun",
                           args = list(comparators = paste(rep('XXXXC', 100), collapse = ''),
                                       h2fs = "h2fs_univariate_linear_fun")),
  required_fitness = 0.02
)
```

### `gcol`

This is just a `data.frame` build by `rbind`ing many different genealogies
together and adding some columns to track the arguments that where used to
call `sim_pop` and that were used to remove individuals from the population.

The extra columns that must be added:

- **`sim_id`:** The id of the simulation. If many simulations are run in a
  loop using the same `arg_set` this column is the primary mechanism that
  distinguishes the simulations from each other.
- **`label`:** The label is used to match the simulation to the arguments that
  were used call `sim_pop` or sample from the genealogy.
- **`sampling`:** The sampling appoach applied to the original genealogy that
  was produced by `sim_pop`. Valid values include:
  * `fit_threshold`
  * `size_matched_sampling`
  * `none`

### `dsum`

Due to the memory requiremented of storing full genealogies (or distance
matrices), it is often preferable to immediately compute and summarize a
distance matrix on the last generation of a genealogy and to delete both the
genealogy and distance matrix from memory. A `dsum` is a list in which each
element summarized a single distance matrix and contains additional elements
to help identify it. These additional elements are the same as the extra
columns added to the `gcol` data structure:

- **`sim_id`:** The id of the simulation. If many simulations are run in a
  loop using the same `arg_set` this column is the primary mechanism that
  distinguishes the simulations from each other.
- **`label`:** The label is used to match the simulation to the arguments that
  were used call `sim_pop` or sample from the genealogy.
- **`sampling`:** The sampling appoach applied to the original genealogy that
  was produced by `sim_pop`. Valid values include:
  * `fit_threshold`
  * `size_matched_sampling`
  * `none`

Each element of a `dsum` also have three additional elements that contains the
summary metrics:

- `perc`: the percentiles of the distribution,
- `avg_hd`: the average of all the pairwise distances,
- `dens` : an estimate of the distribution as produced by `density()`

The root level elements of the `dsum` list should not be named since the
identifier elements that match the extra columns of a `gcol` should be used to
identify the elements.








