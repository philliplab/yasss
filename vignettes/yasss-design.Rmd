---
title: "Design of yasss"
author: "Phillip Labuschagne"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  echo = FALSE
)
```

## Overall Design

yasss is designed to simulate genealogies which are stored in `data.frames`. A
high level summary of the core simulation functions are provided below:

`sim_pop`

* loop over number of generations
  + `sim_next_gen`
    - loop over all parents
      * `mutator`: mutate parent seq into offspring seq
  + `fitness_evaluator`

It quickly became clear that most simulations will involve many datasets
generated with distinct sets of arguments. Functionality to track this extra
structure was added to yasss.

## Managing multiple simulations

The genealogy `data.frames` rapidly become too large to store in memory. Thus
there are two different approaches to managing the data from multiple
simulations. The first is to store the full genealogies, which is useful for
smaller simulations and for troubleshooting. The second approach reduces memory
consumption by summarizing each genealogy as it is simulated and only saving the
summary metrics. The summary metrics include:

- the percentiles of the distribution,
- the average of all the pairwise distances,
- and, an estimate of the distribution as produced by `density()`

Another structure that exists in the data is a pair (or set) generated by
applying different fitness cutoffs (criteria) to a genealogy. While the
computation of fitness scores is part of the `sim_pop` function, these scores
can be updated at a later stage using the `assign_fitness` function with the
`last_generation_only` argument set to FALSE. However, this attempt at
managing the data will not handle this case where different
`fitness_evaluators` are used on a single genealogy. Instead, we will assume
that the fitness scores are only computed once during the call to `sim_pop`.
Future versions may lift this restriction on the data management component,
which will require the creation of a complex mechanism for managing the
argument sets, since the arguments that pertain specifically to `sim_pop` will
have to be separated from the arguments that are used only in the
`fitness_evaluator`.

A genealogy is typically used in one of three states: 

- the `fitness_scores` are ignored,
- `get_fit_offspring` is used to obtain a genealogy based only on fit
  individuals whose ancestors were also fit and finally, or 
- a random sampling from the last generation of the genealogy to match the
  size to a fitness restricted version that was generated with
  `get_fit_offspring`.

In general, we will further group these three states. Either we will
completely ignore the `fitness_scores` or we will construct a `fit_unfit_pair`
in which `get_fit_offspring` is used to generated a fitness restricted
genealogy and then a random sample is generated ignoring fitness scores to
generated a matched (based on number of individuals) pair.

This complexity is tracked in the following data structures:

- `arg_set`: A list that contains the arguments for `sim_pop` **AND** a
  required fitness **AND** a label. Thus an `arg_set` contains enough
  information to produce a fit/unfit pair. The label will be used later to
  associate the simulated data with the `arg_set` that was used to produce it.
  *Note: In the future multiple fitness evaluators may be applied to the same
  genealogy which will require a more complex `arg_set` concept.*
- `dsum`: Summary of the distance matrix (percentiles, avg, density). This is a
  list with an element for each distance matrix that was produced.
- `gcol`: A collection of genealogies. This is the main memory consuming
  culprit. It is just a string of genealogy data.frames rbinded together with
  extra columns added that tracks the `genealogy_id`, the `arg_set` that was
  used to produce it and the fitness requirement that had to be satisfied.

### `arg_set`

An example of one of an `arg_set` based on one of the original specifications.

```{r, eval = FALSE, echo = TRUE}
arg_element <- list(
  label = 'A',
  ancestors = paste(rep("A", 500), collapse = ''),
  r0 = 2,
  n_gen = n_gen,
  n_pop = Inf,
  mutator = list(fun = "mutator_uniform_fun",
                 args = list(mu = 1/250)),
  fitness_evaluator = list(fun = "fitness_evaluator_homology_fun",
                           args = list(comparators = paste(rep('XXXXC', 100), collapse = ''),
                                       h2fs = "h2fs_univariate_linear_fun"))
)

arg_sets <- list(`1` = list(group_label = "restricted_A",
                            group_desc = "with r0 = 2, 10 generations and mu equal to 1/500 and required fitness of 0.03 vs A",
                            args = args1),
                 `2` = list(group_label = "unrestricted_A",
                            group_desc = "with r0 = 2, 10 generations and mu equal to 1/500 and a random sample to match the size of the fitness restricted version vs A",
                            args = args1))

```

### `dsum`

### `gcol`












