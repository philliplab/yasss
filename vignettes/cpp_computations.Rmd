---
title: "Rcpp vs pure R performance"
author: "Phillip Labuschagne"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
library(yasss)

# toggle the speed_up variable during development.
speed_up <- 10
speeding_it_up <- speed_up > 1
```

```{r, eval = speeding_it_up}
for (i in 1:10){
print('Speeding up the process for development')
print(speed_up)
}
```

To improve performance, various parts of the simulations were implemented in
C++ and accessed via Rcpp. This vignette explains some of the weirder things
that had to be done to get this working and presents a detailed performance
comparison.

## Passing Rcpp functions into Rcpp functions.

Due to the way the mutators and fitness_evaluators are specified in the sim_pop
call, we need to check that you can actually pass functions to Rcpp and that
the performance hits are not too large.

To test this, write a silly function in Rcpp and pass it to another silly
function in Rcpp.

R performs poorly when you grow data structures or when you update a data.frame
repeatedly. So write a C++ function that produces a fibonacci-like sequence and then
write another function that repeatedly call s this fibonacci-like sequence generator
and populates a data.frame with it. Instead of adding the two previous numbers
to each other add the imediately preceding number to the 4th power root of the
number preceding it. Making this modification keeps the number sizes under
control. This will be a good indicator of the performance characteristics for
the kinds of calculations in yass.

### Pure R

```{r}
fibo <- function(s1, s2, n){
  result <- c(s1, s2)
  for (i in 3:n){
    result <- c(result, result[i-2]^0.25 + result[i-1])
  }
  result
}

fibo_df <- function(n, n_columns = 20){
  x <- data.frame()
  for (i in 1:n_columns){
    x[,paste("V", i, sep = '')] <- numeric(0)
  }
  s1 <- 1
  s2 <- 1
  for (i in 1:n){
    y <- fibo(s1, s2, n_columns+2)
    y <- matrix(y[3:(n_columns+2)], ncol = n_columns)
    y <- as.data.frame(y)
    x <- rbind(x, y)
  }
  x
}

print('Time required to compute 50000 elements of the sequence')
start_time <- proc.time()
x <- fibo(1, 1, 50000/speed_up)
print(proc.time() - start_time)

print('Time required to compute 400 x 400 matrix')
start_time <- proc.time()
y <- fibo_df(400/speed_up, 400/speed_up)
print(proc.time() - start_time)
```

### Pure C++

```{r}
print('Time required to compute 50000 elements of the sequence')
start_time <- proc.time()
x <- cpp_fibo_exported(1, 1, 50000/speed_up)
print(proc.time() - start_time)

print('Time required to compute 10000 x 10000 matrix')
start_time <- proc.time()
y <- yasss:::cpp_fibo_df(10000/speed_up, 10000/speed_up)
print(proc.time() - start_time)
```

### Passing Rcpp into Rcpp

```{r}
print('Time required to compute 10000 x 10000 matrix')
start_time <- proc.time()
x <- yasss:::cpp_fibo_df_pass(10000/speed_up, 10000/speed_up, cpp_fibo_exported)
print(proc.time() - start_time)

print('Time required to compute 10000 x 10000 matrix')
start_time <- proc.time()
x <- yasss:::cpp_fibo_df_pass(10000/speed_up, 10000/speed_up, yasss:::cpp_fibo)
print(proc.time() - start_time)
```

*IT WORKS !!!!!*

So this means that it is a valid strategy to write a C++ function for the
mutator / fitness_evaluator and then pass that function, via R, into another
C++ function (sim_next_gen / sim_pop).

## Mutators

### mutator_uniform

#### Performance of mutator_uniform_fun

```{r}
print('Time to mutate 5e6 sequence in R')
start_time <- proc.time()
x <- mutator_uniform_fun(paste(rep('A', 5000000/speed_up), sep = '', collapse = ''), 0.1)
print(proc.time() - start_time)
```

#### Performance of cpp_mutator_uniform_fun

```{r}
print('Time to mutate 5e7 sequence in cpp')
start_time <- proc.time()
x <- yasss:::cpp_mutator_uniform_fun(paste(rep('A', 50000000/speed_up), 
                                           sep = '', collapse = ''), 0.1)
print(proc.time() - start_time)
```

10x speedup.


