% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/sim_proc_many_pops.R
\name{sim_proc_many_pops}
\alias{sim_proc_many_pops}
\title{Simulate and process many populations}
\usage{
sim_proc_many_pops(arg_collection, n_sims = 1, output_dmat = FALSE,
  max_dmat_size = 10000, fitness_processing = "none",
  n_gen_with_perfect_fitness = 4, output_genealogy = "none")
}
\arguments{
\item{arg_collection}{The collection of argument sets to be used in the
simulations}

\item{n_sims}{The number of times sim_pop must be called for each arg_set.
The total number of data sets produced will be \code{n_sims *
length(arg_collection)} if no fitness processing is specified and \code{n_sims *
length(arg_collection) * 2} if any fitness processing is specified.}

\item{output_dmat}{If TRUE, the distance matrices will be included in the
output. Uses lots of memory - default is FALSE.}

\item{max_dmat_size}{If more sequences than this number is present in a
last generation on which a distance matrix is about to be computed, then
\code{max_dmat_size} sequences will be randomly sampled and the distance
matrix will only be computed on those sequences. Default is 10000.}

\item{fitness_processing}{The way that the fitness scores should be used to
 sample from the genealogy. Valid options include:
 \itemize{
   \item none: This will produce one dataset per genealogy.
   \item fit_unfit_pair: This will use the threshold approach to remove all unfit
   individuals and their offspring. The remaining members of the last
   generation will be considered to be the fit member of the pair. An equal
   number of individuals will be sampled at random from the original
   genealogy to produce the unfit pair such that it is the same size as the
   fit pair.
   \item fit_unfit_unmatched_pair: Same as fit_unfit_pair except that the
   unfit member will not be down sampled to size match the fit member.
}}

\item{n_gen_with_perfect_fitness}{The number of initial generations that
must be assigned perfect fitness. If an early ancestor has low fitness and
is thus removed, the likelihood that the end up with an empty genealogy is
too large.}

\item{output_genealogy}{Should the genealogy be output? Valid options
include: 'none', 'last_gen_only', and 'full'.}
}
\value{
A list with the following elements:
\itemize{
  \item \code{dcollection}: A \code{dcollection} as checked by \code{\link{check_dcollection}}
  \item \code{arg_collection}: The input \code{arg_collection} as checked by
  \code{\link{check_arg_collection}}.
  \item \code{all_genealogies} [OPTIONAL]: A \code{data.frame} that contains all the
  genealogies, or in the case that \code{last_gen_only} was specified, only the
  last generations of the genealogies and all the identifier columns.
  \item \code{all_dmats} [OPTIONAL]: A list of lists containing the
  distance matrixes and their indentifiers.
  \item \code{n_sims}: The input \code{n_sims} indicating the number of
  datasets you can expect.
}
}
\description{
Simulate and process many populations
}
